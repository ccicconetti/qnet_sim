// SPDX-FileCopyrightText: Â© 2025 Claudio Cicconetti <c.cicconetti@iit.cnr.it>
// SPDX-License-Identifier: MIT

use crate::output::Sample;

#[derive(Debug, PartialEq, Eq)]
pub struct EprGeneratedData {
    pub tx_node_id: u32,
    pub master_node_id: u32,
    pub slave_node_id: u32,
}

#[derive(Debug, PartialEq, Eq)]
pub struct EprNotifiedData {
    pub this_node_id: u32,
    pub peer_node_id: u32,
    pub role: crate::nic::Role,
    pub epr_pair_id: u64,
}

/// Quantum memory cell identifier.
#[derive(Debug, PartialEq, Eq, Clone)]
pub struct MemoryCellId {
    /// Neighbor node ID.
    pub neighbor_node_id: u32,
    /// Role in this logical link.
    pub role: crate::nic::Role,
    /// Local pair ID.
    pub local_pair_id: u64,
}

#[derive(Debug, PartialEq, Eq)]
pub struct EprConsumeData {
    /// ID of the node running the application that requested the EPR.
    /// Used only for
    pub req_app_node_id: u32,
    /// Port of the application that requested the EPR.
    pub req_app_port: u16,
    /// ID of the node that consumes the EPR.
    pub consume_node_id: u32,
    /// Quantum memory cell identifier.
    pub memory_cell_id: MemoryCellId,
}

#[derive(Debug, PartialEq, Eq)]
pub enum NetworkEventData {
    /// New EPR generated by a tx.
    EprGenerated(EprGeneratedData),
    /// EPR pair notified at a node.
    EprNotified(EprNotifiedData),
    /// Consume a half EPR pair and measure its fidelity.
    EprConsume(EprConsumeData),
}

/// Every EPR request is uniquely identified by the five-tuple:
/// - source node ID and port
/// - target node ID and port
/// - request ID
#[derive(Debug, Clone, PartialEq, Eq)]
pub struct EprFiveTuple {
    /// Source node ID.
    pub source_node_id: u32,
    /// Source port.
    pub source_port: u16,
    /// Target node ID.
    pub target_node_id: u32,
    /// Target port.
    pub target_port: u16,
    /// Request ID
    pub request_id: u64,
}

impl EprFiveTuple {
    pub fn new(
        source_node_id: u32,
        source_port: u16,
        target_node_id: u32,
        target_port: u16,
        request_id: u64,
    ) -> Self {
        Self {
            source_node_id,
            source_port,
            target_node_id,
            target_port,
            request_id,
        }
    }
}

impl std::fmt::Display for EprFiveTuple {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "src {}:{} dst {}:{} id {}",
            self.source_node_id,
            self.source_port,
            self.target_node_id,
            self.target_port,
            self.request_id
        )
    }
}

/// Entanglement swapping request body.
#[derive(Debug, PartialEq, Eq)]
pub struct EsRequestData {
    /// EPR identifier.
    pub epr: EprFiveTuple,
    /// Prev hop node, i.e., the node that requests to perform the
    /// entanglement swapping.
    pub prev_hop: u32,
    /// Next hop node, i.e., the node that is requested to perform the
    /// entanglement swapping.
    pub next_hop: u32,
    /// Full path (the request used source routing).
    /// The first node is always the originator of the EPR request, the last
    /// one is always the node hosting the application's peer.
    /// The vector never has less than two elements.
    pub path: Vec<u32>,
    /// Local pair identifier.
    pub local_pair_id: u64,
}

#[derive(Debug, PartialEq, Eq)]
pub enum NodeEventData {
    /// New EPR request requested by an app, identified by the five tuple
    /// Created by an application, consumed by the node where it is running.
    EprRequestApp(EprFiveTuple),
    /// Request to perform entanglement swapping at a node for the creation of
    /// a remote EPR.
    /// Created by a node, consumed by the logical peer that is the next hop
    /// towards the destination.
    EsRequest(EsRequestData),
    /// Local operations completed for an entanglement swapping.
    /// Created by a node when a local operation (BSM or X/Z correction) is
    /// required, consumed by the same node when the operation is completed
    /// (successfully or with failure is decided by the handler of this event).
    EsLocalComplete(EsRequestData),
    /// Successful response to a request to perform entanglement swapping.
    /// Created by a node, consumed by the logical peer that is the previous
    /// hop in the path from the source to the destination of the ES.
    EsSuccess(EsRequestData),
    /// Failed response to a request to perform entanglement swapping.
    /// Created by a node, consumed by the logical peer that is the previous
    /// hop in the path from the source to the destination of the ES.
    EsFailure(EsRequestData),
    /// Entanglement swapping operation failed.
    /// Created by the node where end-to-end EPR creation fails.
    /// Consumed by the nodes along the path from the source to this node
    /// that have pending resources to be freed.
    EsRemoteFailed(EprFiveTuple),
    /// Entanglement swapping operation completed successfully.
    /// Created by the destination node. Consumed by the source node.
    EsRemoteComplete(EprFiveTuple),
}

impl NodeEventData {
    pub fn node_id(&self) -> u32 {
        match self {
            NodeEventData::EprRequestApp(data)
            | NodeEventData::EsRemoteComplete(data)
            | NodeEventData::EsRemoteFailed(data) => data.source_node_id,
            NodeEventData::EsRequest(data) | NodeEventData::EsLocalComplete(data) => data.next_hop,
            NodeEventData::EsSuccess(data) | NodeEventData::EsFailure(data) => data.prev_hop,
        }
    }
}

#[derive(Debug, PartialEq, Eq)]
pub struct EprResponseData {
    /// Five-tuple associated with this EPR.
    pub epr: EprFiveTuple,
    /// The boolean is true if the EPR response is associated with the source
    /// node; it is false if it is associated with the target, instead.
    pub is_source: bool,
    /// Memory cell ID. If None then the request failed.
    pub memory_cell: Option<MemoryCellId>,
}

#[derive(Debug, PartialEq, Eq)]
pub enum AppEventData {
    /// New EPR request needed by an app, identified by node ID and port.
    /// Created by an application, consumed by the same application.
    EprRequest(u32, u16),
    /// EPR request response from a node.
    /// Created by a node, consumed by the application that requested the EPR
    /// (is_source == true) and by its peer (is_source == false).
    EprResponse(EprResponseData),
    /// Local operations complete for a given EPR request.
    /// Created by an application, consumed by the same application.
    LocalComplete(EprFiveTuple),
    /// Remote operations complete for a given EPR request.
    /// The boolean is true if the network latency has to be added.
    /// /// Created by an application, consumed by its peer.
    RemoteComplete(EprFiveTuple),
}

impl AppEventData {
    pub fn node_id(&self) -> u32 {
        match self {
            Self::EprRequest(node_id, _port) => *node_id,
            Self::EprResponse(data) => {
                if data.is_source {
                    data.epr.source_node_id
                } else {
                    data.epr.target_node_id
                }
            }
            Self::LocalComplete(data) => data.source_node_id,
            Self::RemoteComplete(data) => data.source_node_id,
        }
    }

    pub fn port(&self) -> u16 {
        match self {
            Self::EprRequest(_node_id, port) => *port,
            Self::EprResponse(data) => {
                if data.is_source {
                    data.epr.source_port
                } else {
                    data.epr.target_port
                }
            }
            Self::LocalComplete(data) | Self::RemoteComplete(data) => data.source_port,
        }
    }
}

#[derive(Debug, PartialEq, Eq)]
pub enum EventType {
    /// The warm-up period expires.
    WarmupPeriodEnd,
    /// The simulation ends.
    ExperimentEnd,
    /// Print progress.
    Progress(u16),

    /// Network event.
    NetworkEvent(NetworkEventData),
    /// Node event.
    NodeEvent(NodeEventData),
    /// Application event.
    AppEvent(AppEventData),
}

#[derive(PartialEq, Eq, Debug)]
pub struct Trasfer {
    pub src_node_id: u32,
    pub dst_node_id: u32,
    pub done: bool,
}

impl Trasfer {
    pub fn new(src_node_id: u32, dst_node_id: u32) -> Self {
        Self {
            src_node_id,
            dst_node_id,
            done: false,
        }
    }
}

/// A simulation event.
#[derive(PartialEq, Eq)]
pub struct Event {
    /// The simulated time associated with the event.
    time: u64,
    /// The event type.
    pub event_type: EventType,
    /// If specified, the event has to be handled by the target component after
    /// classical communication latency has been added on the path between the
    /// source (.0) and destination (.1).
    pub transfer: Option<Trasfer>,
}

impl Event {
    /// Create a new event to be executed at the specified relative time, in s.
    pub fn new(time: f64, event_type: EventType) -> Self {
        Self {
            time: crate::utils::to_nanoseconds(time),
            event_type,
            transfer: None,
        }
    }

    /// Create a new event to be executed by the target after a classical
    /// communication latency is added between the source and destination.
    pub fn new_transfer(event_type: EventType, src_node_id: u32, dst_node_id: u32) -> Self {
        Self {
            time: 0,
            event_type,
            transfer: Some(Trasfer::new(src_node_id, dst_node_id)),
        }
    }

    /// Return the time of the event, in ns.
    pub fn time(&self) -> u64 {
        self.time
    }

    // Advance the event time by the specified period, in ns.
    pub fn advance(&mut self, advance_time: u64) {
        self.time += advance_time
    }

    /// Return the node that should handle the event.
    pub fn target_node_id(&self) -> u32 {
        match &self.event_type {
            EventType::AppEvent(data) => data.node_id(),
            EventType::NodeEvent(data) => data.node_id(),
            _ => panic!(
                "event of type {:?} does not have a target node",
                self.event_type
            ),
        }
    }
}

#[allow(clippy::non_canonical_partial_ord_impl)]
impl PartialOrd for Event {
    fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering> {
        other.time().partial_cmp(&self.time())
    }
}

impl Ord for Event {
    fn cmp(&self, other: &Self) -> std::cmp::Ordering {
        self.partial_cmp(other).unwrap()
    }
}

pub trait EventHandler {
    fn handle(&mut self, event: Event) -> (Vec<Event>, Vec<Sample>);
    fn initial(&mut self) -> Vec<Event>;
}
